/**
 * CCL AI Fill — generates intake fields for a Client Care Letter using Azure OpenAI.
 *
 * POST /api/ccl-ai/fill
 *   Body: { matterId, practiceArea, description, clientName, opponent, enquiryNotes?, handlerName?, handlerRole? }
 *   Returns: { ok, fields: Record<string, string>, confidence, model, durationMs }
 *
 * The 26 "intake" fields that used to require manual questionnaire entry
 * are now generated by AI from matter context.
 */
const express = require('express');
const path = require('path');
const sql = require('mssql');
const { chatCompletion, DEPLOYMENT } = require('../utils/aiClient');
const { trackEvent, trackException, trackMetric } = require('../utils/appInsights');
const { getPool } = require('../utils/db');

const router = express.Router();

// ─── Practice area defaults (fallback if AI fails) ─────────────────────────
const PRACTICE_AREA_DEFAULTS = {
    commercial: {
        insert_current_position_and_scope_of_retainer: 'We will review the relevant documentation, advise you on your legal position, and take such steps as are agreed to protect your commercial interests.',
        next_steps: 'review the documents you have provided and advise on the merits of your position',
        realistic_timescale: '4-6 weeks for initial advice',
        next_stage: 'document review and initial advice',
        charges_estimate_paragraph: 'I estimate the cost of the Initial Scope will be in the region of £2,500 to £5,000 plus VAT, depending on the complexity of the documentation involved.',
        disbursements_paragraph: 'We do not anticipate significant disbursements at this stage.',
        figure: '2,500',
        figure_or_range: '2,500 - 5,000',
        estimate: '£2,500 to £5,000 plus VAT',
        and_or_intervals_eg_every_three_months: 'monthly',
        insert_next_step_you_would_like_client_to_take: 'Provide all relevant contractual documentation',
        state_why_this_step_is_important: 'We cannot advise properly without sight of the key documents',
        insert_consequence: 'we will be unable to progress your matter',
        state_amount: '2,500',
        describe_first_document_or_information_you_need_from_your_client: 'Copy of the relevant contract or agreement',
        describe_second_document_or_information_you_need_from_your_client: 'All relevant correspondence with the other party',
        describe_third_document_or_information_you_need_from_your_client: 'Any supporting invoices, payment records, or evidence',
    },
    property: {
        insert_current_position_and_scope_of_retainer: 'We will act on your behalf in connection with the property transaction, dealing with all necessary legal formalities through to completion.',
        next_steps: 'review the title documentation and raise any necessary enquiries',
        realistic_timescale: '8-12 weeks to completion',
        next_stage: 'title review and pre-contract enquiries',
        charges_estimate_paragraph: 'I estimate our charges for this transaction will be in the region of £1,500 to £3,000 plus VAT, depending on the complexity of the title and any issues that arise.',
        disbursements_paragraph: 'Disbursements are likely to include Land Registry fees, search fees, and any Stamp Duty Land Tax payable. We estimate these at approximately £500 to £1,500.',
        figure: '1,500',
        figure_or_range: '1,500 - 3,000',
        estimate: '£1,500 to £3,000 plus VAT',
        and_or_intervals_eg_every_three_months: 'on completion',
        insert_next_step_you_would_like_client_to_take: 'Complete and return the property information questionnaire',
        state_why_this_step_is_important: 'We need this information to prepare the contract pack',
        insert_consequence: 'there may be delays in progressing the transaction',
        state_amount: '1,500',
        describe_first_document_or_information_you_need_from_your_client: 'Title deeds or Land Registry documents',
        describe_second_document_or_information_you_need_from_your_client: 'Proof of identity and address',
        describe_third_document_or_information_you_need_from_your_client: 'Mortgage offer (if applicable)',
    },
    employment: {
        insert_current_position_and_scope_of_retainer: 'We will review the circumstances of your employment matter, advise you on your legal position and rights, and take such steps as are agreed to protect your interests.',
        next_steps: 'review the documents you have provided and advise on your position and options',
        realistic_timescale: '2-4 weeks for initial advice',
        next_stage: 'document review and initial advice on merits',
        charges_estimate_paragraph: 'I estimate the cost of the Initial Scope will be in the region of £1,500 to £3,000 plus VAT.',
        disbursements_paragraph: 'We do not anticipate significant disbursements at this stage.',
        figure: '1,500',
        figure_or_range: '1,500 - 3,000',
        estimate: '£1,500 to £3,000 plus VAT',
        and_or_intervals_eg_every_three_months: 'monthly',
        insert_next_step_you_would_like_client_to_take: 'Provide copies of your employment contract and any relevant correspondence',
        state_why_this_step_is_important: 'We need to understand the full contractual position before advising',
        insert_consequence: 'we will be unable to advise you properly',
        state_amount: '1,500',
        describe_first_document_or_information_you_need_from_your_client: 'Employment contract and any amendments',
        describe_second_document_or_information_you_need_from_your_client: 'Relevant correspondence (grievances, disciplinary letters, etc.)',
        describe_third_document_or_information_you_need_from_your_client: 'Any other supporting documentation',
    },
    construction: {
        insert_current_position_and_scope_of_retainer: 'We will review the construction dispute, advise on your contractual and statutory rights, and take such steps as are agreed to resolve the matter.',
        next_steps: 'review the contract and associated documents, and advise on the merits of your position',
        realistic_timescale: '4-8 weeks for initial advice',
        next_stage: 'contract review and initial advice',
        charges_estimate_paragraph: 'I estimate the cost of the Initial Scope will be in the region of £3,000 to £7,500 plus VAT, reflecting the technical complexity of construction matters.',
        disbursements_paragraph: 'Disbursements may include expert surveyor or engineer fees if required. We will discuss these with you before incurring them.',
        figure: '3,000',
        figure_or_range: '3,000 - 7,500',
        estimate: '£3,000 to £7,500 plus VAT',
        and_or_intervals_eg_every_three_months: 'monthly',
        insert_next_step_you_would_like_client_to_take: 'Provide all relevant contractual documentation and correspondence',
        state_why_this_step_is_important: 'Construction disputes are document-intensive and we need the full picture',
        insert_consequence: 'we may not be able to assess the merits of your claim',
        state_amount: '3,000',
        describe_first_document_or_information_you_need_from_your_client: 'The building contract and any variations',
        describe_second_document_or_information_you_need_from_your_client: 'Relevant correspondence, including any notices served',
        describe_third_document_or_information_you_need_from_your_client: 'Photographs, surveys, or expert reports (if available)',
    },
    'dispute-resolution': {
        insert_current_position_and_scope_of_retainer: 'We will review the circumstances of your dispute, advise on the merits and available resolution options, and take such steps as are agreed.',
        next_steps: 'review the documents you have provided and advise on the strengths of your position',
        realistic_timescale: '4-6 weeks for initial advice',
        next_stage: 'document review and merits assessment',
        charges_estimate_paragraph: 'I estimate the cost of the Initial Scope will be in the region of £2,000 to £5,000 plus VAT.',
        disbursements_paragraph: 'Disbursements at this stage are likely to be minimal. Should court proceedings be necessary, court fees and barrister fees will be discussed with you in advance.',
        figure: '2,000',
        figure_or_range: '2,000 - 5,000',
        estimate: '£2,000 to £5,000 plus VAT',
        and_or_intervals_eg_every_three_months: 'monthly',
        insert_next_step_you_would_like_client_to_take: 'Provide all relevant documentation and a chronology of events',
        state_why_this_step_is_important: 'We need to understand the full factual background before advising',
        insert_consequence: 'we will be unable to properly assess the merits of your case',
        state_amount: '2,000',
        describe_first_document_or_information_you_need_from_your_client: 'The relevant contracts or agreements',
        describe_second_document_or_information_you_need_from_your_client: 'All correspondence with the other party',
        describe_third_document_or_information_you_need_from_your_client: 'Any evidence supporting your position (invoices, photographs, etc.)',
    },
};

// ─── System prompt ─────────────────────────────────────────────────────────
const SYSTEM_PROMPT = `You are a senior UK solicitor at Helix Law, a specialist litigation firm. Helix Law acts across four core practice areas: commercial disputes (shareholder and partnership disputes, investment and loan disputes, debt recovery, statutory demands, civil fraud, contract disputes, restrictive covenants, injunctions), property disputes (landlord and tenant, evictions, boundary and land disputes), construction disputes (adjudication, payment disputes, contract breaches, unlawful terminations), and employment law. The firm is SRA-regulated (ID 565557) and based in Brighton. Your task is to generate the intake fields for a Client Care Letter (CCL) based on the matter context provided.

The CCL is a regulatory requirement under SRA rules. It must be professional, accurate, and tailored to the specific matter. Write in clear, professional British English suitable for a client who is not legally trained.

CRITICAL: You are filling in the placeholder fields of a REAL legal template. Each field you generate is injected verbatim into the letter — it MUST read naturally in context. Below is how each field appears in the actual template so you understand exactly where your output goes.

TEMPLATE CONTEXT (how your fields are used — {{field_name}} = your output):

Section 2 — Scope of services:
"{{insert_current_position_and_scope_of_retainer}} ("Initial Scope")"
→ This is the opening paragraph of the scope section. Write 2-4 complete sentences describing what the client has instructed Helix Law to do. Must be specific to this matter. Ends with the text ("Initial Scope") which is added by the template.

Section 3 — Next steps:
"The next steps in your matter are {{next_steps}}."
→ Start lowercase. This completes the sentence. List 2-3 specific actions.

"We expect this will take {{realistic_timescale}}."
→ A realistic period, e.g. "4-6 weeks" or "2-3 months".

Section 4.1 — Charges:
"My rate is £{{handler_hourly_rate}} per hour."
→ Number only (already auto-filled, but if missing use the rate given in context).

"{{charges_estimate_paragraph}}"
→ 1-3 complete sentences estimating fees for the Initial Scope. Include a £ range plus VAT. Base this on the deal amount, pitch email amount, or practice area norms. Must be realistic.

Section 4.2 — Disbursements:
"{{disbursements_paragraph}}"
→ 1-2 complete sentences about likely disbursements for this matter type.

Section 4.3 — Costs other party:
"{{costs_other_party_paragraph}}"
→ 1-2 sentences. If there is an opponent: note the risk. If no opponent/not litigation: "We do not expect that you will have to pay another party's costs."

Section 6 — Payment on account:
"Please provide us with £{{figure}} on account of costs."
→ Number only, no £ sign, e.g. "2,500". Usually 50-100% of the low end of the estimate range.

Section 7 — Costs updates:
"We have agreed to provide you with an update on the amount of costs when appropriate as the matter progresses{{and_or_intervals_eg_every_three_months}}."
→ Starts with a space or ", " then the interval. Usually " monthly" or " every three months".

Section 13 — Duties to court:
"Your matter {{may_will}} involve court proceedings."
→ Either "may" or "will". Use "may" unless court proceedings are certain.

Section 18 — Action points:
"☐ {{insert_next_step_you_would_like_client_to_take}} | {{state_why_this_step_is_important}}"
→ insert_next_step: Imperative sentence — what the client must do. Be specific to this matter.
→ state_why_this_step_is_important: Why it matters. 1 sentence.

"☐ Provide a payment on account of costs and disbursements of £{{state_amount}} | If we do not receive a payment on account... {{insert_consequence}}"
→ state_amount: Same as figure.
→ insert_consequence: What happens if they don't pay, e.g. "we may not be able to start work on your matter"

"{{describe_first_document_or_information_you_need_from_your_client}}"
"{{describe_second_document_or_information_you_need_from_your_client}}"
"{{describe_third_document_or_information_you_need_from_your_client}}"
→ Each is a bullet point. Be specific to this matter type — name the actual documents needed.

NOT IN TEMPLATE (metadata fields):
- "next_stage": Brief label for the next milestone (used for internal tracking, not shown to client)
- "figure_or_range": Cost estimate range, e.g. "2,500 - 5,000" (used in sidebar display)
- "estimate": Full estimate string, e.g. "£2,500 to £5,000 plus VAT"
- "in_total_including_vat_or_for_the_next_steps_in_your_matter": Either "in total, including VAT" or "for the next steps in your matter"
- "give_examples_of_what_your_estimate_includes_eg_accountants_report_and_court_fees": Brief list of what the estimate covers
- "we_cannot_give_an_estimate_of_our_overall_charges_in_this_matter_because_reason_why_estimate_is_not_possible": If estimate IS possible, set to "". Only fill if genuinely impossible.
- "simple_disbursements_estimate": Estimated disbursements (number only, e.g. "500")

COST ACCURACY RULES:
1. If a Deal Amount is provided, the costs estimate MUST be consistent with it. The payment on account (figure) should be 50-100% of the deal amount.
2. If a Pitch Email is provided, match its quoted figures exactly — the client has already seen these numbers.
3. If neither is available, use practice area norms for a UK specialist litigation firm.
4. Never invent costs figures that are wildly different from the deal/pitch context.

Respond with ONLY a JSON object containing these fields. No markdown, no explanation, just the JSON object.`;

// ─── Gather full workbench context from all sources ────────────────────────

function getInternalBase() {
    const port = process.env.PORT || 8080;
    const isNamedPipe = typeof port === 'string' && port.startsWith('\\\\.\\pipe\\');
    return isNamedPipe && process.env.WEBSITE_HOSTNAME
        ? `https://${process.env.WEBSITE_HOSTNAME}`
        : `http://localhost:${port}`;
}

async function fetchJson(url) {
    try {
        const resp = await fetch(url);
        if (!resp.ok) return null;
        return await resp.json();
    } catch { return null; }
}

async function getTableColumns(pool, tableName) {
    const result = await pool.request()
        .input('tableName', sql.NVarChar(128), tableName)
        .query(`
            SELECT COLUMN_NAME
            FROM INFORMATION_SCHEMA.COLUMNS
            WHERE TABLE_NAME = @tableName
        `);
    return new Set((result.recordset || []).map((row) => String(row.COLUMN_NAME || '').trim()).filter(Boolean));
}

function resolveOrderBy(columns, candidates) {
    for (const candidate of candidates) {
        if (columns.has(candidate)) return candidate;
    }
    return null;
}

function buildDebugContext(fullContext, contextSources) {
    const makeSnippet = (value, limit = 350) => {
        const text = String(value || '').trim();
        if (!text) return '';
        return text.length > limit ? `${text.slice(0, limit)}…` : text;
    };

    return {
        contextFields: {
            practiceArea: fullContext.practiceArea || '',
            typeOfWork: fullContext.typeOfWork || '',
            clientName: fullContext.clientName || '',
            opponent: fullContext.opponent || '',
            handlerName: fullContext.handlerName || '',
            handlerRole: fullContext.handlerRole || '',
            handlerRate: fullContext.handlerRate || '',
            dealAmount: fullContext.dealAmount || '',
            pitchAmount: fullContext.pitchAmount || '',
            enquiryValue: fullContext.enquiryValue || '',
            instructionStage: fullContext.instructionStage || '',
            company: fullContext.company || '',
            clientType: fullContext.clientType || '',
            source: fullContext.source || '',
        },
        sourceCount: contextSources.length,
        sources: contextSources,
        snippets: {
            initialCallNotes: makeSnippet(fullContext.initialCallNotes),
            enquiryNotes: makeSnippet(fullContext.enquiryNotes),
            instructionNotes: makeSnippet(fullContext.instructionNotes),
            dealServiceDescription: makeSnippet(fullContext.dealServiceDescription),
            pitchServiceDescription: makeSnippet(fullContext.pitchServiceDescription),
            pitchEmailBody: makeSnippet(fullContext.pitchEmailBody),
            callTranscripts: makeSnippet(fullContext.callTranscripts, 450),
        },
    };
}

function formatFallbackReason(errorMessage) {
    const message = String(errorMessage || '').trim();
    if (!message) return 'Unknown AI error';
    const lower = message.toLowerCase();
    if (lower.includes('deployment') && lower.includes('does not exist')) {
        return `Azure OpenAI deployment '${DEPLOYMENT}' is not available for this resource. Check AZURE_OPENAI_DEPLOYMENT and Azure deployment naming.`;
    }
    return message;
}

async function gatherFullContext(matterId, instructionRef) {
    const context = {};
    const base = getInternalBase();
    const instrConnStr = process.env.INSTRUCTIONS_SQL_CONNECTION_STRING;
    const coreConnStr = process.env.SQL_CONNECTION_STRING;

    // ── 1. Resolve InstructionRef + ProspectId from Instructions DB ──
    // The frontend may pass an HLX-format instructionRef directly (preferred)
    // or a Clio displayNumber as matterId (fallback).
    let resolvedInstructionRef = instructionRef || null;
    let prospectId = null;
    let phone = null;

    if (instrConnStr) {
        try {
            const pool = await getPool(instrConnStr);
            const instructionsColumns = await getTableColumns(pool, 'Instructions');
            const instructionsOrderBy = resolveOrderBy(instructionsColumns, ['CreatedAt', 'UpdatedAt', 'InstructionDateTime', 'InstructionRef']);
            const instructionsProspectColumn = resolveOrderBy(instructionsColumns, ['ProspectId', 'prospectId', 'id', 'acid']);

            const pitchContentColumns = await getTableColumns(pool, 'PitchContent');
            const pitchOrderBy = resolveOrderBy(pitchContentColumns, ['CreatedAt', 'UpdatedAt', 'PitchId', 'Id']);

            const instructionsOrderClause = instructionsOrderBy ? `ORDER BY ${instructionsOrderBy} DESC` : '';
            const pitchOrderClause = pitchOrderBy ? `ORDER BY ${pitchOrderBy} DESC` : '';

            const instructionSelectParts = [
                'InstructionRef',
                instructionsProspectColumn ? `${instructionsProspectColumn} AS ProspectId` : `NULL AS ProspectId`,
                'Stage', 'FirstName', 'LastName',
                'Notes', 'Phone', 'Email', 'CompanyName', 'HelixContact',
                'Title', 'Gender', 'ClientType',
            ];

            // Build WHERE clause — prefer exact InstructionRef match, fall back to matterId
            const whereParts = [];
            const inputParams = [];
            if (resolvedInstructionRef) {
                whereParts.push("InstructionRef = @InstructionRef");
                inputParams.push({ name: 'InstructionRef', type: sql.NVarChar(100), value: resolvedInstructionRef });
            }
            // Also try matterId patterns as fallback
            whereParts.push("InstructionRef LIKE '%' + @MatterId + '%'");
            inputParams.push({ name: 'MatterId', type: sql.NVarChar(100), value: matterId });
            if (instructionsProspectColumn) {
                whereParts.push(`${instructionsProspectColumn} = @MatterId`);
            }

            const request = pool.request();
            for (const param of inputParams) {
                request.input(param.name, param.type, param.value);
            }

            // Try matching by matter ID patterns
            const instrResult = await request
                .query(`SELECT TOP 1 
                    ${instructionSelectParts.join(',\n                    ')}
                FROM Instructions
                WHERE ${whereParts.join('\n                   OR ')}
                     ${instructionsOrderClause}`);

            if (instrResult.recordset.length > 0) {
                const row = instrResult.recordset[0];
                resolvedInstructionRef = row.InstructionRef;
                prospectId = row.ProspectId;
                phone = row.Phone;
                context.instructionNotes = row.Notes || '';
                context.instructionStage = row.Stage || '';
                context.clientType = row.ClientType || '';
                context.companyName = row.CompanyName || '';
                if (row.Gender) context.clientGender = row.Gender;
            }

            // Get deal data (service description, amount, pitch info)
            if (resolvedInstructionRef) {
                const dealResult = await pool.request()
                    .input('InstructionRef', sql.NVarChar(100), resolvedInstructionRef)
                    .query(`SELECT TOP 1
                        ServiceDescription, Amount, Status, PitchedBy,
                        CloseDate, PitchValidUntil
                    FROM Deals
                    WHERE InstructionRef = @InstructionRef
                    ORDER BY DealId DESC`);

                if (dealResult.recordset.length > 0) {
                    const deal = dealResult.recordset[0];
                    context.dealServiceDescription = deal.ServiceDescription || '';
                    context.dealAmount = deal.Amount ? String(deal.Amount) : '';
                    context.dealPitchedBy = deal.PitchedBy || '';
                }
            }

            // Get pitch content (the actual email sent to the client)
            if (resolvedInstructionRef) {
                const pitchResult = await pool.request()
                    .input('InstructionRef', sql.NVarChar(100), resolvedInstructionRef)
                    .query(`SELECT TOP 1
                        EmailSubject, EmailBody, Amount, ServiceDescription, Notes
                    FROM PitchContent
                    WHERE InstructionRef = @InstructionRef
                    ${pitchOrderClause}`);

                if (pitchResult.recordset.length > 0) {
                    const pitch = pitchResult.recordset[0];
                    context.pitchEmailBody = pitch.EmailBody || '';
                    context.pitchServiceDescription = pitch.ServiceDescription || '';
                    context.pitchAmount = pitch.Amount ? String(pitch.Amount) : '';
                    context.pitchNotes = pitch.Notes || '';
                }
            }
        } catch (err) {
            console.warn('[CCL-AI] Instructions DB lookup failed:', err.message);
        }
    }

    // ── 2. Core Data enquiry (initial call notes — often the richest text) ──
    // If we don't have a prospectId from Instructions DB, try to find it via
    // the matters table using the Clio displayNumber.
    if (coreConnStr && !prospectId) {
        try {
            const pool = await getPool(coreConnStr);
            const mattersResult = await pool.request()
                .input('DisplayNumber', sql.NVarChar(100), matterId)
                .query(`SELECT TOP 1 [Client Name], [Unique ID], [Display Number]
                    FROM matters
                    WHERE [Display Number] = @DisplayNumber`);

            if (mattersResult.recordset.length > 0) {
                const matterRow = mattersResult.recordset[0];
                const clientName = matterRow['Client Name'] || '';
                // Try to find the enquiry by client name
                if (clientName) {
                    const nameParts = clientName.trim().split(/\s+/);
                    const firstName = nameParts[0] || '';
                    const lastName = nameParts.slice(1).join(' ') || '';
                    if (firstName && lastName) {
                        const enqResult = await pool.request()
                            .input('FirstName', sql.NVarChar(100), firstName)
                            .input('LastName', sql.NVarChar(100), lastName)
                            .query(`SELECT TOP 1 ID
                                FROM enquiries
                                WHERE First_Name = @FirstName AND Last_Name = @LastName
                                ORDER BY ID DESC`);
                        if (enqResult.recordset.length > 0) {
                            prospectId = enqResult.recordset[0].ID;
                        }
                    }
                }
            }
        } catch (err) {
            console.warn('[CCL-AI] Matters cross-reference lookup failed:', err.message);
        }
    }

    if (coreConnStr && prospectId) {
        try {
            const pool = await getPool(coreConnStr);
            const result = await pool.request()
                .input('ProspectId', sql.Int, Number(prospectId))
                .query(`SELECT TOP 1
                    First_Name, Last_Name, Email, Phone_Number,
                    Area_of_Work, [Type of Work], Company, 
                    [Initial_first_call_notes], Notes, Source,
                    [Additional Information], Value, Rating,
                    [Point_of_Contact], [Method_of_Contact]
                FROM enquiries
                WHERE ID = @ProspectId
                ORDER BY ID DESC`);

            if (result.recordset.length > 0) {
                const row = result.recordset[0];
                // Initial call notes are usually the richest source
                context.initialCallNotes = row.Initial_first_call_notes || '';
                context.enquiryNotes = row.Notes || row['Additional Information'] || '';
                context.areaOfWork = row.Area_of_Work || '';
                context.typeOfWork = row['Type of Work'] || '';
                context.source = row.Source || '';
                context.company = row.Company || context.companyName || '';
                context.enquiryValue = row.Value ? String(row.Value) : '';
                context.methodOfContact = row.Method_of_Contact || '';
                if (!phone) phone = row.Phone_Number;
            }
        } catch (err) {
            console.warn('[CCL-AI] Core Data enquiry lookup failed:', err.message);
        }
    }

    // ── 3. CallRail transcripts (if we have a phone number) ──
    if (phone) {
        try {
            // CallRail endpoint is POST, so use fetch directly
            const resp = await fetch(`${base}/api/callrailCalls`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ phoneNumber: phone, maxResults: 5 }),
            });
            if (resp.ok) {
                const calls = await resp.json();
                const transcripts = (Array.isArray(calls) ? calls : calls.calls || [])
                    .filter(c => c.transcription || c.note)
                    .slice(0, 3) // limit to 3 most recent for token budget
                    .map(c => {
                        const parts = [];
                        if (c.startTime) parts.push(`[${new Date(c.startTime).toLocaleDateString('en-GB')}]`);
                        if (c.direction) parts.push(`(${c.direction})`);
                        if (c.duration) parts.push(`${Math.round(c.duration / 60)}min`);
                        if (c.note) parts.push(`Notes: ${c.note}`);
                        if (c.transcription) parts.push(`Transcript: ${c.transcription.substring(0, 1500)}`);
                        return parts.join(' ');
                    });
                if (transcripts.length > 0) {
                    context.callTranscripts = transcripts.join('\n---\n');
                }
            }
        } catch (err) {
            console.warn('[CCL-AI] CallRail lookup failed:', err.message);
        }
    }

    // ── 4. Pitch emails (from pitches endpoint using ProspectId) ──
    if (prospectId && !context.pitchEmailBody) {
        try {
            const pitchData = await fetchJson(`${base}/api/pitches/${prospectId}`);
            if (pitchData && Array.isArray(pitchData) && pitchData.length > 0) {
                const latest = pitchData[0];
                context.pitchEmailBody = context.pitchEmailBody || latest.EmailBody || '';
                context.pitchServiceDescription = context.pitchServiceDescription || latest.ServiceDescription || '';
                context.pitchAmount = context.pitchAmount || (latest.Amount ? String(latest.Amount) : '');
            }
        } catch (err) {
            console.warn('[CCL-AI] Pitches lookup failed:', err.message);
        }
    }

    return context;
}

// ─── Build user prompt from all available context ──────────────────────────
function buildUserPrompt(data) {
    const parts = [];

    // Core matter details
    parts.push(`MATTER CONTEXT:`);
    parts.push(`- Practice Area: ${data.practiceArea || data.areaOfWork || 'General'}`);
    if (data.typeOfWork) parts.push(`- Type of Work: ${data.typeOfWork}`);
    parts.push(`- Client Name: ${data.clientName || 'Not specified'}`);
    parts.push(`- Matter Description: ${data.description || 'Not specified'}`);
    if (data.opponent) parts.push(`- Opposing Party: ${data.opponent}`);
    if (data.handlerName) parts.push(`- Handler: ${data.handlerName} (${data.handlerRole || 'Solicitor'})`);
    if (data.handlerRate) parts.push(`- Handler Hourly Rate: £${data.handlerRate}`);
    if (data.company) parts.push(`- Client Company: ${data.company}`);
    if (data.clientType) parts.push(`- Client Type: ${data.clientType}`);
    if (data.clientGender) parts.push(`- Client Gender: ${data.clientGender}`);
    if (data.enquiryValue) parts.push(`- Enquiry Value: £${data.enquiryValue}`);
    if (data.source) parts.push(`- Enquiry Source: ${data.source}`);
    if (data.instructionStage) parts.push(`- Instruction Stage: ${data.instructionStage}`);

    // Deal data (what was pitched and agreed)
    if (data.dealServiceDescription || data.dealAmount) {
        parts.push(`\nDEAL INFORMATION:`);
        if (data.dealServiceDescription) parts.push(`Service: ${data.dealServiceDescription}`);
        if (data.dealAmount) parts.push(`Agreed Amount: £${data.dealAmount}`);
        if (data.dealPitchedBy) parts.push(`Pitched By: ${data.dealPitchedBy}`);
    }

    // Pitch email (what the client was actually told)
    if (data.pitchEmailBody) {
        parts.push(`\nPITCH EMAIL SENT TO CLIENT (use this to match scope and costs):`);
        parts.push(data.pitchEmailBody.substring(0, 3000));
    } else if (data.pitchServiceDescription) {
        parts.push(`\nPITCH SERVICE DESCRIPTION: ${data.pitchServiceDescription}`);
        if (data.pitchAmount) parts.push(`Pitch Amount: £${data.pitchAmount}`);
    }

    // Initial call notes (often the richest text)
    if (data.initialCallNotes) {
        parts.push(`\nINITIAL CALL NOTES (first contact with client):`);
        parts.push(data.initialCallNotes.substring(0, 3000));
    }

    // Enquiry notes
    if (data.enquiryNotes && data.enquiryNotes !== data.initialCallNotes) {
        parts.push(`\nENQUIRY NOTES:`);
        parts.push(data.enquiryNotes.substring(0, 2000));
    }

    // Instruction notes
    if (data.instructionNotes) {
        parts.push(`\nINSTRUCTION NOTES:`);
        parts.push(data.instructionNotes.substring(0, 2000));
    }

    // Call transcripts
    if (data.callTranscripts) {
        parts.push(`\nCALL TRANSCRIPTS (conversations with client):`);
        parts.push(data.callTranscripts.substring(0, 4000));
    }

    // Pitch notes
    if (data.pitchNotes) {
        parts.push(`\nPITCH NOTES: ${data.pitchNotes.substring(0, 1000)}`);
    }

    parts.push(`\nGenerate all CCL intake fields for this matter. Be specific and tailored — the client should read this letter and feel it was written specifically for their situation. Use the pitch email and deal amounts to match the costs figures. Use the call transcripts and notes to understand what the client actually needs.`);

    return parts.join('\n');
}

// ─── Summarise what data sources were used (for prompt transparency) ───────
function summariseContextSources(dbContext) {
    const sources = [];
    if (dbContext.initialCallNotes) sources.push('Initial call notes');
    if (dbContext.enquiryNotes) sources.push('Enquiry notes');
    if (dbContext.instructionNotes) sources.push('Instruction notes');
    if (dbContext.pitchEmailBody) sources.push('Pitch email');
    if (dbContext.pitchServiceDescription) sources.push('Pitch service description');
    if (dbContext.dealServiceDescription) sources.push('Deal information');
    if (dbContext.callTranscripts) sources.push('Call transcripts');
    if (dbContext.areaOfWork) sources.push('Area of work classification');
    if (dbContext.typeOfWork) sources.push('Type of work');
    if (dbContext.company) sources.push('Company details');
    return sources;
}

// ─── POST /api/ccl-ai/fill ─────────────────────────────────────────────────
router.post('/fill', async (req, res) => {
    const {
        matterId, instructionRef, practiceArea, description, clientName,
        opponent, enquiryNotes, handlerName, handlerRole, handlerRate,
    } = req.body || {};

    if (!matterId) {
        return res.status(400).json({ error: 'matterId is required' });
    }

    const trackingId = Math.random().toString(36).slice(2, 10);
    const startMs = Date.now();
    // Aligned with enquiry-processing-v2: no max_tokens — let the model decide.
    const chatOptions = {
        temperature: 0.2,
    };

    trackEvent('CCL.AiFill.Started', {
        trackingId,
        matterId: String(matterId),
        practiceArea: practiceArea || 'unknown',
        deployment: DEPLOYMENT,
    });

    try {
        // 1. Gather full workbench context from all sources
        const dbContext = await gatherFullContext(matterId, instructionRef);

        // 2. Merge all context
        const fullContext = {
            practiceArea: practiceArea || dbContext.areaOfWork || '',
            typeOfWork: dbContext.typeOfWork || '',
            description,
            clientName,
            opponent,
            handlerName,
            handlerRole,
            handlerRate,
            clientType: dbContext.clientType || '',
            clientGender: dbContext.clientGender || '',
            company: dbContext.company || '',
            source: dbContext.source || '',
            enquiryValue: dbContext.enquiryValue || '',
            instructionStage: dbContext.instructionStage || '',
            initialCallNotes: dbContext.initialCallNotes || '',
            enquiryNotes: enquiryNotes || dbContext.enquiryNotes || '',
            instructionNotes: dbContext.instructionNotes || '',
            dealServiceDescription: dbContext.dealServiceDescription || '',
            dealAmount: dbContext.dealAmount || '',
            dealPitchedBy: dbContext.dealPitchedBy || '',
            pitchEmailBody: dbContext.pitchEmailBody || '',
            pitchServiceDescription: dbContext.pitchServiceDescription || '',
            pitchAmount: dbContext.pitchAmount || '',
            pitchNotes: dbContext.pitchNotes || '',
            callTranscripts: dbContext.callTranscripts || '',
        };

        // 3. Build prompt and call AI
        const userPrompt = buildUserPrompt(fullContext);
        const contextSources = summariseContextSources(dbContext);
        const debugContext = buildDebugContext(fullContext, contextSources);
        const aiFields = await chatCompletion(SYSTEM_PROMPT, userPrompt, chatOptions);

        const durationMs = Date.now() - startMs;

        // 4. Validate — ensure we got real fields back
        const expectedKeys = [
            'insert_current_position_and_scope_of_retainer',
            'next_steps',
            'charges_estimate_paragraph',
        ];
        const hasCore = expectedKeys.every(k => aiFields[k] && aiFields[k].length > 10);

        if (!hasCore || aiFields._parseError) {
            // Partial AI response — merge with practice area defaults
            const paKey = normalisePracticeArea(practiceArea);
            const defaults = PRACTICE_AREA_DEFAULTS[paKey] || PRACTICE_AREA_DEFAULTS['commercial'];
            const merged = { ...defaults, ...stripEmpty(aiFields) };

            trackEvent('CCL.AiFill.PartialFallback', {
                trackingId, matterId: String(matterId), practiceArea: paKey, durationMs: String(durationMs),
            });

            return res.json({
                ok: true,
                fields: merged,
                confidence: 'partial',
                model: DEPLOYMENT,
                durationMs,
                source: 'ai+defaults',
                dataSources: contextSources,
                contextSummary: `Used ${contextSources.length} data source(s): ${contextSources.join(', ')}`,
                userPrompt,
                systemPrompt: SYSTEM_PROMPT,
                fallbackReason: 'AI response was incomplete or unparsable; merged with defaults.',
                debug: {
                    trackingId,
                    deployment: DEPLOYMENT,
                    aiStatus: 'partial',
                    options: chatOptions,
                    userPromptLength: userPrompt.length,
                    generatedFieldCount: Object.keys(stripEmpty(aiFields)).length,
                    context: debugContext,
                },
            });
        }

        trackEvent('CCL.AiFill.Completed', {
            trackingId,
            matterId: String(matterId),
            practiceArea: practiceArea || 'unknown',
            durationMs: String(durationMs),
            fieldCount: String(Object.keys(aiFields).length),
        });
        trackMetric('CCL.AiFill.Duration', durationMs, { practiceArea: practiceArea || 'unknown' });

        return res.json({
            ok: true,
            fields: aiFields,
            confidence: 'full',
            model: DEPLOYMENT,
            durationMs,
            source: 'ai',
            dataSources: contextSources,
            contextSummary: `Used ${contextSources.length} data source(s): ${contextSources.join(', ')}`,
            userPrompt,
            systemPrompt: SYSTEM_PROMPT,
            debug: {
                trackingId,
                deployment: DEPLOYMENT,
                aiStatus: 'complete',
                options: chatOptions,
                userPromptLength: userPrompt.length,
                generatedFieldCount: Object.keys(stripEmpty(aiFields)).length,
                context: debugContext,
            },
        });

    } catch (err) {
        const durationMs = Date.now() - startMs;
        console.error(`[CCL-AI] Fill failed (trackingId: ${trackingId}):`, err.message);
        trackException(err, {
            operation: 'CCL.AiFill',
            trackingId,
            matterId: String(matterId),
            practiceArea: practiceArea || 'unknown',
        });
        trackEvent('CCL.AiFill.Failed', {
            trackingId, matterId: String(matterId), error: err.message, durationMs: String(durationMs),
        });

        // Fall back to practice area defaults
        const paKey = normalisePracticeArea(practiceArea);
        const defaults = PRACTICE_AREA_DEFAULTS[paKey] || PRACTICE_AREA_DEFAULTS['commercial'];

        const fallbackReason = formatFallbackReason(err.message);

        return res.json({
            ok: true,
            fields: defaults,
            confidence: 'fallback',
            model: 'none',
            durationMs,
            source: 'defaults',
            fallbackReason,
            dataSources: [],
            contextSummary: 'AI unavailable — using practice area defaults only',
            userPrompt: '',
            systemPrompt: SYSTEM_PROMPT,
            debug: {
                trackingId,
                deployment: DEPLOYMENT,
                aiStatus: 'fallback',
                options: chatOptions,
                userPromptLength: 0,
                generatedFieldCount: 0,
                error: fallbackReason,
                context: {
                    sourceCount: 0,
                    sources: [],
                    snippets: {},
                    contextFields: {
                        practiceArea: practiceArea || '',
                        clientName: clientName || '',
                        opponent: opponent || '',
                    },
                },
            },
        });
    }
});

// ─── POST /api/ccl-ai/feedback ──────────────────────────────────────────────
router.post('/feedback', async (req, res) => {
    const { matterId, rating, comment, fieldKey, timestamp } = req.body || {};

    if (!matterId || !rating) {
        return res.status(400).json({ error: 'matterId and rating are required' });
    }

    const allowed = ['up', 'down', 'flag'];
    if (!allowed.includes(rating)) {
        return res.status(400).json({ error: `rating must be one of: ${allowed.join(', ')}` });
    }

    try {
        // Log to Application Insights as structured event
        trackEvent('CCL.AiFill.Feedback', {
            matterId: String(matterId),
            rating,
            comment: comment || '',
            fieldKey: fieldKey || 'overall',
            timestamp: timestamp || new Date().toISOString(),
            user: req.headers['x-user-email'] || req.headers['x-ms-client-principal-name'] || 'unknown',
        });

        console.log(`[CCL-AI] Feedback: ${rating} for matter ${matterId}${fieldKey ? ` (field: ${fieldKey})` : ''}${comment ? ` — "${comment}"` : ''}`);

        return res.json({ ok: true, recorded: true });
    } catch (err) {
        console.error('[CCL-AI] Feedback recording failed:', err.message);
        trackException(err, { operation: 'CCL.AiFill.Feedback', matterId: String(matterId) });
        return res.status(500).json({ error: 'Failed to record feedback' });
    }
});

// ─── GET /api/ccl-ai/practice-defaults/:area ───────────────────────────────
router.get('/practice-defaults/:area', (req, res) => {
    const paKey = normalisePracticeArea(req.params.area);
    const defaults = PRACTICE_AREA_DEFAULTS[paKey];
    if (!defaults) {
        return res.status(404).json({ error: `No defaults for practice area: ${req.params.area}` });
    }
    return res.json({ ok: true, fields: defaults, practiceArea: paKey });
});

// ─── Helpers ───────────────────────────────────────────────────────────────
function normalisePracticeArea(raw) {
    if (!raw) return 'commercial';
    const lower = raw.toLowerCase().replace(/[^a-z\s-]/g, '').trim();

    if (lower.includes('property') || lower.includes('conveyancing') || lower.includes('real estate')) return 'property';
    if (lower.includes('employment') || lower.includes('hr') || lower.includes('workforce')) return 'employment';
    if (lower.includes('construction') || lower.includes('building')) return 'construction';
    if (lower.includes('dispute') || lower.includes('litigation') || lower.includes('civil')) return 'dispute-resolution';
    if (lower.includes('commercial') || lower.includes('contract') || lower.includes('company') || lower.includes('corporate')) return 'commercial';

    return 'commercial'; // default
}

function stripEmpty(obj) {
    if (!obj || typeof obj !== 'object') return {};
    const result = {};
    for (const [k, v] of Object.entries(obj)) {
        if (k.startsWith('_')) continue;
        if (typeof v === 'string' && v.trim().length > 0) {
            result[k] = v;
        }
    }
    return result;
}

module.exports = router;
