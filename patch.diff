diff --git a/src/index.tsx b/src/index.tsx
index 24c16f032e023984ad5f3927df6b49c9849473a6..55001596a81c0012bed3deaf133c16435dcdf3a8 100644
--- a/src/index.tsx
+++ b/src/index.tsx
@@ -112,70 +112,110 @@ async function fetchUserData(objectId: string): Promise<UserData[]> {
   if (cached) return cached;
 
   const response = await fetch(
     `${process.env.REACT_APP_PROXY_BASE_URL}/${process.env.REACT_APP_GET_USER_DATA_PATH}?code=${process.env.REACT_APP_GET_USER_DATA_CODE}`,
     {
       method: "POST",
       headers: { "Content-Type": "application/json" },
       body: JSON.stringify({ userObjectId: objectId }),
     },
   );
   if (!response.ok)
     throw new Error(`Failed to fetch user data: ${response.status}`);
   const data = await response.json();
   setCachedData(cacheKey, data);
   return data;
 }
 
 async function fetchEnquiries(
   email: string,
   dateFrom: string,
   dateTo: string,
 ): Promise<Enquiry[]> {
   const cacheKey = `enquiries-${email}-${dateFrom}-${dateTo}`;
   const cached = getCachedData<Enquiry[]>(cacheKey);
   if (cached) return cached;
-  
-  // Build query parameters for the new decoupled function
-  const params = new URLSearchParams();
-  if (dateFrom) params.append('dateFrom', dateFrom);
-  if (dateTo) params.append('dateTo', dateTo);
-  // Note: email parameter not used in new function as it filters by different fields
-  
-  const response = await fetch(
-    `/api/enquiries?${params.toString()}`,
+
+  // Always fetch the legacy enquiries data
+  const legacyResponse = await fetch(
+    `${process.env.REACT_APP_PROXY_BASE_URL}/${process.env.REACT_APP_GET_ENQUIRIES_PATH}?code=${process.env.REACT_APP_GET_ENQUIRIES_CODE}`,
     {
-      method: "GET",
+      method: "POST",
       headers: { "Content-Type": "application/json" },
+      body: JSON.stringify({ email, dateFrom, dateTo }),
     },
   );
-  if (!response.ok)
-    throw new Error(`Failed to fetch enquiries: ${response.status}`);
-  const data = await response.json();
-  const enquiries = data.enquiries || [];
-  setCachedData(cacheKey, enquiries);
-  return enquiries;
+  if (!legacyResponse.ok)
+    throw new Error(`Failed to fetch enquiries: ${legacyResponse.status}`);
+  const legacyData = await legacyResponse.json();
+  let legacyEnquiries: Enquiry[] = [];
+  if (Array.isArray(legacyData)) {
+    legacyEnquiries = legacyData as Enquiry[];
+  } else if (Array.isArray(legacyData.enquiries)) {
+    legacyEnquiries = legacyData.enquiries as Enquiry[];
+  }
+
+  const normalizedEmail = email.toLowerCase();
+  const isLzUser = [
+    "lz@helix-law.com",
+    "lukasz@helix-law.com",
+    "luke@helix-law.com",
+  ].includes(normalizedEmail);
+
+  let combined = legacyEnquiries;
+
+  if (isLzUser) {
+    try {
+      const params = new URLSearchParams();
+      if (dateFrom) params.append("dateFrom", dateFrom);
+      if (dateTo) params.append("dateTo", dateTo);
+
+      const newResponse = await fetch(`/api/enquiries?${params.toString()}`, {
+        method: "GET",
+        headers: { "Content-Type": "application/json" },
+      });
+
+      if (newResponse.ok) {
+        const newData = await newResponse.json();
+        const newEnquiries: Enquiry[] = newData.enquiries || [];
+
+        // Merge and deduplicate by ID if present
+        const seen = new Set<string>();
+        combined = [...legacyEnquiries, ...newEnquiries].filter((e: any) => {
+          const id = String(e.ID ?? e.id ?? "");
+          if (seen.has(id)) return false;
+          seen.add(id);
+          return true;
+        });
+      }
+    } catch (err) {
+      console.warn("Failed to fetch new enquiries", err);
+    }
+  }
+
+  setCachedData(cacheKey, combined);
+  return combined;
 }
 
 async function fetchMatters(fullName: string): Promise<Matter[]> {
   const cacheKey = `matters-${fullName}`;
   const cached = getCachedData<Matter[]>(cacheKey);
   if (cached) return cached;
 
   const response = await fetch(
     `${process.env.REACT_APP_PROXY_BASE_URL}/${process.env.REACT_APP_GET_MATTERS_PATH}?code=${process.env.REACT_APP_GET_MATTERS_CODE}`,
     {
       method: "POST",
       headers: { "Content-Type": "application/json" },
       body: JSON.stringify({ fullName }),
     },
   );
   if (!response.ok)
     throw new Error(`Failed to fetch matters: ${response.status}`);
   const data = await response.json();
 
   const mapData = (items: any[]): Matter[] => {
     return items.map((item) => ({
       MatterID: item["MatterID"] || item["Matter ID"] || "",
       InstructionRef: item["InstructionRef"] || item["Instruction Ref"] || "",
       DisplayNumber: item["Display Number"] || "",
       OpenDate: item["Open Date"] || "",
diff --git a/src/index.tsx b/src/index.tsx
index 24c16f032e023984ad5f3927df6b49c9849473a6..55001596a81c0012bed3deaf133c16435dcdf3a8 100644
--- a/src/index.tsx
+++ b/src/index.tsx
@@ -288,51 +328,51 @@ const AppWithContext: React.FC = () => {
     }
   };
 
   useEffect(() => {
     const initializeTeamsAndFetchData = async () => {
       if (inTeams && !useLocalData) {
         try {
           microsoftTeams.initialize();
           microsoftTeams.getContext(async (ctx) => {
             setTeamsContext(ctx);
 
             const objectId = ctx.userObjectId || "";
             if (!objectId) throw new Error("Missing Teams context objectId.");
 
             const { dateFrom, dateTo } = getDateRange();
 
             // 1. Fetch user data first to get full name
             const userDataRes = await fetchUserData(objectId);
             setUserData(userDataRes);
 
             const fullName =
               `${userDataRes[0]?.First} ${userDataRes[0]?.Last}`.trim() || "";
 
             // 2. In parallel, fetch enquiries, matters, and team data
             const [enquiriesRes, mattersRes, teamDataRes] = await Promise.all([
-              fetchEnquiries("anyone", dateFrom, dateTo),
+              fetchEnquiries(userDataRes[0]?.Email || "", dateFrom, dateTo),
               fetchMatters(fullName),
               fetchTeamData(),
             ]);
 
             setEnquiries(enquiriesRes);
             setMatters(mattersRes);
             setTeamData(teamDataRes);
 
             setLoading(false);
           });
         } catch (err: any) {
           console.error("Error initializing or fetching data:", err);
           setError(err.message || "Unknown error occurred.");
 
           setLoading(false);
         }
       } else {
         console.warn("Using local sample data for development.");
         setTeamsContext({
           userObjectId: "local",
           userPrincipalName: "lz@helix-law.com",
           theme: "default",
         } as microsoftTeams.Context);
         
         // Initialize local user data with selected areas
