diff --git a/src/index.tsx b/src/index.tsx
index f14d0d488b8d5c6448558d311dec5ba9e444274d..7e94c21c20a3ae95caefb31d01f49905633a2380 100644
--- a/src/index.tsx
+++ b/src/index.tsx
@@ -121,116 +121,78 @@ async function fetchUserData(objectId: string): Promise<UserData[]> {
   return data;
 }
 
 async function fetchEnquiries(
   email: string,
   dateFrom: string,
   dateTo: string,
   userAow: string = '',
 ): Promise<Enquiry[]> {
   const cacheKey = `enquiries-${email}-${dateFrom}-${dateTo}-${userAow}`;
   const cached = getCachedData<Enquiry[]>(cacheKey);
   if (cached) return cached;
 
   // Always fetch the legacy enquiries data
   const legacyResponse = await fetch(
     `${process.env.REACT_APP_PROXY_BASE_URL}/${process.env.REACT_APP_GET_ENQUIRIES_PATH}?code=${process.env.REACT_APP_GET_ENQUIRIES_CODE}`,
     {
       method: "POST",
       headers: { "Content-Type": "application/json" },
       body: JSON.stringify({ email, dateFrom, dateTo }),
     },
   );
   if (!legacyResponse.ok)
     throw new Error(`Failed to fetch enquiries: ${legacyResponse.status}`);
   const legacyData = await legacyResponse.json();
-  let legacyEnquiries: Enquiry[] = [];
+  let enquiries: Enquiry[] = [];
   if (Array.isArray(legacyData)) {
-    legacyEnquiries = legacyData as Enquiry[];
+    enquiries = legacyData as Enquiry[];
   } else if (Array.isArray(legacyData.enquiries)) {
-    legacyEnquiries = legacyData.enquiries as Enquiry[];
-  }
-
-  const normalizedEmail = email.toLowerCase();
-  const isLzUser = [
-    "lz@helix-law.com",
-    "lukasz@helix-law.com",
-    "luke@helix-law.com",
-  ].includes(normalizedEmail);
-
-  let combined = legacyEnquiries;
-
-  if (isLzUser) {
-    try {
-      const params = new URLSearchParams();
-      if (dateFrom) params.append("dateFrom", dateFrom);
-      if (dateTo) params.append("dateTo", dateTo);
-
-      const newResponse = await fetch(`/api/enquiries?${params.toString()}`, {
-        method: "GET",
-        headers: { "Content-Type": "application/json" },
-      });
-
-      if (newResponse.ok) {
-        const newData = await newResponse.json();
-        const newEnquiries: Enquiry[] = newData.enquiries || [];
-
-        // Merge and deduplicate by ID if present
-        const seen = new Set<string>();
-        combined = [...legacyEnquiries, ...newEnquiries].filter((e: any) => {
-          const id = String(e.ID ?? e.id ?? "");
-          if (seen.has(id)) return false;
-          seen.add(id);
-          return true;
-        });
-      }
-    } catch (err) {
-      console.warn("Failed to fetch new enquiries", err);
-    }
+    enquiries = legacyData.enquiries as Enquiry[];
   }
 
   // Apply area-of-work filtering based on user's AOW
   if (userAow) {
     const userAreas = userAow
       .split(',')
       .map((a) => a.trim().toLowerCase())
       .filter(Boolean);
     const hasFullAccess = userAreas.some(
       (a) => a.includes('operations') || a.includes('tech'),
     );
     if (!hasFullAccess) {
-      combined = combined.filter((enq) => {
-        const area = (enq.Area_of_Work || '').toLowerCase();
+      enquiries = enquiries.filter((enq) => {
+        const area = (enq.Area_of_Work || (enq as any).aow || '').toLowerCase();
         return userAreas.some(
           (a) => a === area || a.includes(area) || area.includes(a),
         );
       });
     }
   }
 
-  setCachedData(cacheKey, combined);
-  return combined;
+  setCachedData(cacheKey, enquiries);
+  return enquiries;
 }
 
 async function fetchMatters(fullName: string): Promise<Matter[]> {
   const cacheKey = `matters-${fullName}`;
   const cached = getCachedData<Matter[]>(cacheKey);
   if (cached) return cached;
 
   const response = await fetch(
     `${process.env.REACT_APP_PROXY_BASE_URL}/${process.env.REACT_APP_GET_MATTERS_PATH}?code=${process.env.REACT_APP_GET_MATTERS_CODE}`,
     {
       method: "POST",
       headers: { "Content-Type": "application/json" },
       body: JSON.stringify({ fullName }),
     },
   );
   if (!response.ok)
     throw new Error(`Failed to fetch matters: ${response.status}`);
   const data = await response.json();
 
   const mapData = (items: any[]): Matter[] => {
     return items.map((item) => ({
       MatterID: item["MatterID"] || item["Matter ID"] || "",
       InstructionRef: item["InstructionRef"] || item["Instruction Ref"] || "",
       DisplayNumber: item["Display Number"] || "",
       OpenDate: item["Open Date"] || "",
