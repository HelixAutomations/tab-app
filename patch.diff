diff --git a/src/tabs/instructions/MatterOpening/processingActions.ts b/src/tabs/instructions/MatterOpening/processingActions.ts
index a87c212bbc19bd75d403b55433f04b2a6f4b8c4a..477ac328b693c9a617cb48d8f9e9fa248844a4cf 100644
--- a/src/tabs/instructions/MatterOpening/processingActions.ts
+++ b/src/tabs/instructions/MatterOpening/processingActions.ts
@@ -188,73 +188,77 @@ export const processingActions: ProcessingAction[] = [
                 headers: { 'Content-Type': 'application/json' },
                 body: JSON.stringify(payload)
             });
 
             if (!resp.ok) throw new Error('Failed to record matter request');
             const data = await resp.json();
             return data.message || 'Matter request recorded; further IDs will be patched in later steps';
         }
     },
 
     { label: 'Contact Created/Updated', run: async () => 'Done' },
     { label: 'Databases Updated', run: async () => 'Done' },
     {
         label: 'Clio Contact Created/Updated',
         icon: clioIcon,
         run: async (formData, userInitials) => {
             const resp = await fetch('/api/clio-contacts', {
                 method: 'POST',
                 headers: { 'Content-Type': 'application/json' },
                 body: JSON.stringify({ formData, initials: userInitials })
             });
             if (!resp.ok) throw new Error('Failed to sync Clio contact');
             const data = await resp.json();
             if (!data.ok) throw new Error(data.error || 'Failed to sync Clio contact');
             const names: string[] = [];
+            let emptyTotal = 0;
             clioContactIds = [];
             clioCompanyId = null;
             (data.results || []).forEach((r: any) => {
                 const attrs = r.data?.attributes || {};
                 const id = r.data?.id;
+                if (typeof r.emptyFieldCount === 'number') {
+                    emptyTotal += r.emptyFieldCount;
+                }
                 if (id) {
                     clioContactIds.push(String(id));
                 }
                 if (r.data?.type === 'Company') {
                     clioCompanyId = String(id);
                 }
                 if (attrs.first_name || attrs.last_name) {
                     names.push(`${attrs.first_name || ''} ${attrs.last_name || ''}`.trim());
                 } else if (attrs.name) {
                     names.push(attrs.name);
                 }
             });
             const person = (data.results || []).find((r: any) => r.data?.type === 'Person');
             const newId = person?.data?.id ? String(person.data.id) : null;
             if (newId && clientIdCallback) {
                 clientIdCallback(newId);
             }
-            return `Clio contacts synced: ${names.join(', ')}`;
+            return `Clio contacts synced: ${names.join(', ')} (${emptyTotal} empty fields)`;
         }
     },
     {
         label: 'Clio Matter Opened',
         icon: clioIcon,
         run: async (formData, userInitials) => {
             const resp = await fetch('/api/clio-matters', {
                 method: 'POST',
                 headers: { 'Content-Type': 'application/json' },
                 body: JSON.stringify({ formData, initials: userInitials, contactIds: clioContactIds, companyId: clioCompanyId })
             });
             if (!resp.ok) throw new Error('Failed to create Clio matter');
             const data = await resp.json();
             if (!data.ok) throw new Error(data.error || 'Failed to create Clio matter');
             return `Matter created with ID ${data.matterId}`;
         }
     },
     { label: 'NetDocument Workspace Triggered', run: async () => 'Done' },
     { label: 'Databases Updated', run: async () => 'Done' }
 ];
 // invisible change 2.2
 
 export const initialSteps: ProcessingStep[] = processingActions.map(action => ({
     label: action.label,
     status: 'pending',
