diff --git a/src/tabs/enquiries/pitch-builder/emailUtils.ts b/src/tabs/enquiries/pitch-builder/emailUtils.ts
index 928ef28154f47c332fddc3a8cffb1afac6214268..d7b4bbaecdd96d8050db5658bbe1c24c9f733095 100644
--- a/src/tabs/enquiries/pitch-builder/emailUtils.ts
+++ b/src/tabs/enquiries/pitch-builder/emailUtils.ts
@@ -68,75 +68,98 @@ export function markUnfilledPlaceholders(
   text: string,
   blocks: TemplateBlock[] = templateBlocks
 ): string {
   const placeholders = getLeftoverPlaceholders(blocks);
   let marked = text;
   placeholders.forEach((placeholder) => {
     const regex = new RegExp(escapeRegExp(placeholder), 'g');
     marked = marked.replace(
       regex,
       `<span style="color: ${colours.cta}; font-weight: bold;">${placeholder}</span>`
     );
   });
   return marked;
 }
 
 /**
  * Strips all the highlight <span> attributes (data-placeholder, data-inserted, etc.)
  * so final email doesn't have bright highlighting.
  */
 export function removeHighlightSpans(html: string): string {
   const tempDiv = document.createElement('div');
   tempDiv.innerHTML = html;
 
   // Elements that should be fully removed
   const removeSelectors =
-    '.lock-toggle, .block-sidebar, .sentence-delete, .option-bubble';
+    '.lock-toggle, .block-sidebar, .sentence-delete, .option-bubble, .sentence-handle';
   tempDiv.querySelectorAll(removeSelectors).forEach((el) => el.remove());
 
   // Unwrap any remaining placeholder containers but keep their content
   tempDiv.querySelectorAll('.block-option-list').forEach((el) => {
     const parent = el.parentNode;
     if (!parent) return;
     while (el.firstChild) parent.insertBefore(el.firstChild, el);
     parent.removeChild(el);
   });
 
   // Remove highlight attributes/classes but keep user content
   const cleanupSelectors =
-    '[data-placeholder], [data-inserted], [data-link], [data-sentence], [data-insert], .insert-placeholder, .block-main';
+    '[data-placeholder], [data-inserted], [data-link], [data-sentence], [data-insert], [data-snippet], [data-block-title], .insert-placeholder, .block-main, .block-container';
   tempDiv.querySelectorAll(cleanupSelectors).forEach((el) => {
     el.removeAttribute('data-placeholder');
     el.removeAttribute('data-inserted');
     el.removeAttribute('data-link');
     el.removeAttribute('data-sentence');
     el.removeAttribute('data-insert');
+    el.removeAttribute('data-snippet');
+    el.removeAttribute('data-block-title');
     el.removeAttribute('style');
     el.removeAttribute('contenteditable');
     if ((el as HTMLElement).classList.contains('block-main')) {
       (el as HTMLElement).classList.remove('block-main');
     }
+    if ((el as HTMLElement).classList.contains('block-container')) {
+      (el as HTMLElement).classList.remove('block-container');
+    }
+    if ((el as HTMLElement).classList.contains('insert-placeholder')) {
+      (el as HTMLElement).classList.remove('insert-placeholder');
+    }
+  });
+
+  // Unwrap containers that are purely structural
+  tempDiv.querySelectorAll('[data-block-title]').forEach((el) => {
+    const parent = el.parentNode;
+    if (!parent) return;
+    while (el.firstChild) parent.insertBefore(el.firstChild, el);
+    parent.removeChild(el);
+  });
+
+  tempDiv.querySelectorAll('.block-main, .block-container').forEach((el) => {
+    const parent = el.parentNode;
+    if (!parent) return;
+    while (el.firstChild) parent.insertBefore(el.firstChild, el);
+    parent.removeChild(el);
   });
 
   // Remove label helpers
   tempDiv
     .querySelectorAll('.block-label, .block-label-display')
     .forEach((el) => el.remove());
 
   return tempDiv.innerHTML;
 }
 
 /**
  * When we insert multiline text from the TemplateBlocks, we turn raw newlines into <br />.
  */
 export function cleanTemplateString(template: string): string {
   // Trim the entire string to remove leading/trailing whitespace and newlines
   const trimmedTemplate = template.trim();
   return trimmedTemplate
     .split('\n')
     .map(line => line.trim())
     .join('<br />')
     .replace(/(<br \/>)+$/, '');
 }
 
 /**
  * Wrap all [INSERT ...] placeholders in a span so we can detect them easily.
