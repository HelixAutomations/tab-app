diff --git a/src/app/functionality/FeContext.tsx b/src/app/functionality/FeContext.tsx
index a4aa7d83c1ce38e96b8e4fbb1b1aa9ab3689de59..a529d4e7bda3d554994a0b8dd17271958f88c795 100644
--- a/src/app/functionality/FeContext.tsx
+++ b/src/app/functionality/FeContext.tsx
@@ -164,72 +164,88 @@ export const FeProvider: React.FC<FeProviderProps> = ({ children }) => {
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify({ userObjectId: objectId }),
       });
 
       if (!response.ok) {
         throw new Error(`Failed to fetch user data: ${response.status}`);
       }
 
       const data = await response.json();
       console.log('User Data:', data);
       setSqlData(data); // Assuming user data is set here
       return data;
     } catch (error) {
       console.error('Error fetching user data:', error);
       setFetchUserDataError('Failed to fetch user data.');
       return {};
     }
   }, [getUserDataUrl]);
 
   // Function to fetch Enquiries
   const fetchEnquiries = useCallback(
     async (email: string, dateFrom: string, dateTo: string): Promise<Enquiry[]> => {
       try {
         console.log('Fetching enquiries with dateFrom:', dateFrom, 'dateTo:', dateTo);
 
+        // Always request all enquiries by using the special 'anyone' keyword
+        const legacyRequestEmail = 'anyone';
+
         const legacyResponse = await fetch(getEnquiriesUrl, {
           method: 'POST',
           headers: { 'Content-Type': 'application/json' },
-          body: JSON.stringify({ email, dateFrom, dateTo }),
+          body: JSON.stringify({
+            email: legacyRequestEmail,
+            dateFrom,
+            dateTo,
+          }),
         });
 
         if (!legacyResponse.ok) {
           throw new Error(`HTTP error! status: ${legacyResponse.status}`);
         }
 
         const legacyData = await legacyResponse.json();
-        let legacyEnquiries: Enquiry[] = [];
+        let rawLegacyEnquiries: Enquiry[] = [];
         if (Array.isArray(legacyData.enquiries)) {
-          legacyEnquiries = legacyData.enquiries as Enquiry[];
+          rawLegacyEnquiries = legacyData.enquiries as Enquiry[];
         } else if (Array.isArray(legacyData)) {
-          legacyEnquiries = legacyData as Enquiry[];
+          rawLegacyEnquiries = legacyData as Enquiry[];
         } else {
           console.warn('Unexpected legacy data format:', legacyData);
         }
 
-        setEnquiries(legacyEnquiries);
-        return legacyEnquiries;
+        // Filter to the current user or unclaimed enquiries
+        const userEmail = email.toLowerCase();
+        const filteredLegacyEnquiries = rawLegacyEnquiries.filter((enq: any) => {
+          const pocEmail = (enq.Point_of_Contact || enq.poc || '').toLowerCase();
+          const unclaimedEmails = ['team@helix-law.com'];
+          const isUnclaimed = unclaimedEmails.includes(pocEmail);
+          return pocEmail === userEmail || isUnclaimed;
+        });
+
+        setEnquiries(filteredLegacyEnquiries);
+        return filteredLegacyEnquiries;
       } catch (error) {
         console.error('Error fetching enquiries:', error);
         setFetchEnquiriesError('Failed to fetch enquiries.');
         return [];
       }
     },
     [getEnquiriesUrl]
   );
 
   // Function to fetch Matters
   const fetchMatters = useCallback(
     async (fullName: string): Promise<Matter[]> => {
       try {
         const response = await fetch(getMattersUrl, {
           method: 'POST',
           headers: { 'Content-Type': 'application/json' },
           body: JSON.stringify({ fullName }),
         });
 
         if (!response.ok) {
           throw new Error(`HTTP error! status: ${response.status}`);
         }
 
         const data = await response.json();
         let fetchedMatters: Matter[] = [];
