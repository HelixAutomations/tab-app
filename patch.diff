diff --git a/decoupled-functions/actionSnippet/index.js b/decoupled-functions/actionSnippet/index.js
index 89889528107f6b2603f56a30ada9751c9e2e19f2..df4ae7a3f8325d22dcb800245e1a587323ad16b2 100644
--- a/decoupled-functions/actionSnippet/index.js
+++ b/decoupled-functions/actionSnippet/index.js
@@ -45,57 +45,74 @@ async function actionSnippetHandler(req, context) {
     context.log('Database password ensured');
     const pool = await getSqlPool();
     context.log('SQL pool acquired');
     // Use the "pitchbuilder" schema by default. This allows running
     // locally without setting DB_SCHEMA explicitly while still
     // working with the shared pitchbuilder database.
     const schema = process.env.DB_SCHEMA || 'pitchbuilder';
     context.log(`Processing action: ${action}`);
 
     switch (action) {
         case "getSnippetBlocks": {
             context.log('Fetching snippet blocks');
             const blocksRes = await pool.request().query(`SELECT * FROM ${schema}.DefaultBlocks ORDER BY BlockId`);
             const blocks = blocksRes.recordset || [];
             for (const b of blocks) {
                 const snips = await pool.request()
                     .input("BlockId", sql.Int, b.BlockId)
                     .query(`SELECT * FROM ${schema}.DefaultBlockSnippets WHERE BlockId=@BlockId AND IsApproved=1 ORDER BY SortOrder`);
                 b.snippets = snips.recordset || [];
             }
             context.log(`Fetched ${blocks.length} blocks`);
             return { status: 200, body: JSON.stringify(blocks), headers: { "Content-Type": "application/json" } };
         }
         case "submitSnippetEdit": {
             context.log('Submitting snippet edit');
-            const snippetId = payload.snippetId ?? payload.SnippetId;
+            let snippetId = payload.snippetId ?? payload.SnippetId;
             const content = payload.proposedContent ?? payload.ProposedContent;
             const label = payload.proposedLabel ?? payload.ProposedLabel;
             const sortOrder = payload.proposedSortOrder ?? payload.ProposedSortOrder;
             const blockId = payload.proposedBlockId ?? payload.ProposedBlockId;
             const isNew = payload.isNew ?? payload.IsNew;
             const proposedBy = payload.proposedBy ?? payload.ProposedBy;
+
+            if (isNew && (snippetId === undefined || snippetId === null)) {
+                const insertSnippet = `INSERT INTO ${schema}.DefaultBlockSnippets
+                    (BlockId, Label, Content, SortOrder, CreatedBy)
+                    OUTPUT INSERTED.SnippetId
+                    VALUES (@BlockId, @Label, @Content, @SortOrder, @CreatedBy)`;
+                const res = await pool
+                    .request()
+                    .input("BlockId", sql.Int, blockId)
+                    .input("Label", sql.NVarChar(100), label || "")
+                    .input("Content", sql.NVarChar(sql.MAX), content)
+                    .input("SortOrder", sql.Int, sortOrder ?? 0)
+                    .input("CreatedBy", sql.NVarChar(50), proposedBy)
+                    .query(insertSnippet);
+                snippetId = res.recordset[0].SnippetId;
+                context.log(`New snippet created with id ${snippetId}`);
+            }
             const q = `INSERT INTO ${schema}.DefaultSnippetEdits
             (SnippetId, ProposedContent, ProposedLabel, ProposedSortOrder, ProposedBlockId, IsNew, ProposedBy)
             VALUES (@SnippetId, @Content, @Label, @SortOrder, @BlockId, @IsNew, @ProposedBy)`;
             await pool
                 .request()
                 .input("SnippetId", sql.Int, snippetId)
                 .input("Content", sql.NVarChar(sql.MAX), content)
                 .input("Label", sql.NVarChar(100), label || null)
                 .input("SortOrder", sql.Int, sortOrder ?? null)
                 .input("BlockId", sql.Int, blockId ?? null)
                 .input("IsNew", sql.Bit, isNew ? 1 : 0)
                 .input("ProposedBy", sql.NVarChar(50), proposedBy)
                 .query(q);
             context.log('Snippet edit inserted');
             return { status: 200, body: JSON.stringify({ ok: true }) };
         }
 
         case "approveSnippetEdit": {
             const editId = payload.editId ?? payload.EditId;
             const approvedBy = payload.approvedBy ?? payload.ApprovedBy;
             const reviewNotes = payload.reviewNotes ?? payload.ReviewNotes;
             context.log(`Approving snippet edit ${editId}`);
             const editRes = await pool
                 .request()
                 .input("EditId", sql.Int, editId)
