diff --git a/src/tabs/enquiries/pitch-builder/EditorAndTemplateBlocks.tsx b/src/tabs/enquiries/pitch-builder/EditorAndTemplateBlocks.tsx
index b23e67e0ed8948c62222ecdda445b2e484d6d442..6316ba5a632ecdda7bf32cfe7fda312309657759 100644
--- a/src/tabs/enquiries/pitch-builder/EditorAndTemplateBlocks.tsx
+++ b/src/tabs/enquiries/pitch-builder/EditorAndTemplateBlocks.tsx
@@ -6,74 +6,76 @@ import SnippetEditPopover from './SnippetEditPopover';
 import { placeholderSuggestions } from '../../../app/customisation/InsertSuggestions';
 import { wrapInsertPlaceholders } from './emailUtils';
 
 interface EditorAndTemplateBlocksProps {
   isDarkMode: boolean;
   body: string;
   setBody: (body: string) => void;
   templateBlocks: TemplateBlock[];
   selectedTemplateOptions: { [key: string]: string | string[] };
   insertedBlocks: { [key: string]: boolean };
   lockedBlocks: { [key: string]: boolean };
   editedBlocks: { [key: string]: boolean };
   handleMultiSelectChange: (blockTitle: string, selectedOptions: string[]) => void;
   handleSingleSelectChange: (blockTitle: string, optionKey: string) => void;
   insertTemplateBlock: (block: TemplateBlock, optionLabel: string | string[], focus?: boolean) => void;
   renderPreview: (block: TemplateBlock) => React.ReactNode;
   applyFormat: (...args: any[]) => void;
   saveSelection: () => void;
   handleInput: (e: React.FormEvent<HTMLDivElement>) => void;
   handleBlur: (e: React.FocusEvent<HTMLDivElement>) => void;
   handleClearBlock: (block: TemplateBlock) => void;
   bodyEditorRef: React.RefObject<HTMLDivElement>;
   toolbarStyle?: any;
   bubblesContainerStyle?: any;
   saveCustomSnippet?: (blockTitle: string, label?: string, sortOrder?: number, isNew?: boolean) => Promise<void>;
+  markBlockAsEdited?: (blockTitle: string, edited: boolean) => void;
 }
 
 const EditorAndTemplateBlocks: React.FC<EditorAndTemplateBlocksProps> = ({
   isDarkMode,
   body,
   setBody,
   templateBlocks,
   selectedTemplateOptions,
   insertedBlocks,
   lockedBlocks,
   editedBlocks,
   handleMultiSelectChange,
   handleSingleSelectChange,
   insertTemplateBlock,
   renderPreview,
   applyFormat,
   saveSelection,
   handleInput,
   handleBlur,
   handleClearBlock,
   bodyEditorRef,
   toolbarStyle,
   bubblesContainerStyle,
   saveCustomSnippet,
+  markBlockAsEdited,
 }) => {
   const [snippetEditState, setSnippetEditState] = useState<{
     blockTitle: string;
     optionLabel: string;
     target: HTMLElement;
   } | null>(null);
   const [showOriginal, setShowOriginal] = useState<Record<string, boolean>>({});
   const [showActionPopup, setShowActionPopup] = useState<{[key: string]: boolean}>({});
   const [editedContent, setEditedContent] = useState<Record<string, Record<string, string>>>({});
   const [collapsedBlocks, setCollapsedBlocks] = useState<Record<string, boolean>>({});
   const [removedBlocks, setRemovedBlocks] = useState<Record<string, boolean>>({});
   const editorRefs = useRef<Record<string, HTMLDivElement>>({});
   const syncTimeoutRef = useRef<NodeJS.Timeout | null>(null);
 
   // Add missing handler functions
   const handleAddPlaceholder = (event: React.MouseEvent, blockTitle: string, optionLabel: string) => {
     event.stopPropagation();
     const editorKey = `${blockTitle}-${optionLabel}`;
     const editorEl = editorRefs.current[editorKey];
     
     if (editorEl) {
       // Get current selection/cursor position
       const selection = window.getSelection();
       if (selection && selection.rangeCount > 0) {
         const range = selection.getRangeAt(0);
diff --git a/src/tabs/enquiries/pitch-builder/EditorAndTemplateBlocks.tsx b/src/tabs/enquiries/pitch-builder/EditorAndTemplateBlocks.tsx
index b23e67e0ed8948c62222ecdda445b2e484d6d442..6316ba5a632ecdda7bf32cfe7fda312309657759 100644
--- a/src/tabs/enquiries/pitch-builder/EditorAndTemplateBlocks.tsx
+++ b/src/tabs/enquiries/pitch-builder/EditorAndTemplateBlocks.tsx
@@ -200,50 +202,51 @@ const EditorAndTemplateBlocks: React.FC<EditorAndTemplateBlocksProps> = ({
           target.contentEditable = 'false';
           target.style.border = 'none';
           target.removeEventListener('blur', handleBlur);
           target.removeEventListener('keydown', handleEnter);
         };
         
         const handleEnter = (e: KeyboardEvent) => {
           if (e.key === 'Enter') {
             e.preventDefault();
             target.blur();
           }
         };
         
         target.addEventListener('blur', handleBlur);
         target.addEventListener('keydown', handleEnter);
       }
     };
 
     document.addEventListener('click', handlePlaceholderClick);
     return () => {
       document.removeEventListener('click', handlePlaceholderClick);
     };
   }, []);
 
   const handleTabChange = (block: TemplateBlock, optionKey: string) => {
+    if (editedBlocks[block.title]) return;
     handleSingleSelectChange(block.title, optionKey);
     // Content will be updated by the useEffect below
   };
 
   // Update content when selected option changes (but not when editing content)
   useEffect(() => {
     templateBlocks
       .filter(block => !removedBlocks[block.title]) // Only process non-removed blocks
       .forEach(block => {
       const selectedOption = getSelectedOption(block);
       const editorKey = `${block.title}-${selectedOption}`;
       const editorEl = editorRefs.current[editorKey];
       
       if (editorEl) {
         const selectedOpt = block.options.find(opt => opt.label === selectedOption);
         if (selectedOpt) {
           // Only update content if the editor is not currently focused (to avoid cursor jumping)
           if (document.activeElement !== editorEl) {
             const editedText = editedContent[block.title]?.[selectedOption];
             const contentToShow = editedText || wrapInsertPlaceholders(selectedOpt.previewText);
             
             // Only update if content is different to avoid cursor jumping
             if (editorEl.innerHTML !== contentToShow) {
               // Use a timeout to avoid React conflicts
               setTimeout(() => {
diff --git a/src/tabs/enquiries/pitch-builder/EditorAndTemplateBlocks.tsx b/src/tabs/enquiries/pitch-builder/EditorAndTemplateBlocks.tsx
index b23e67e0ed8948c62222ecdda445b2e484d6d442..6316ba5a632ecdda7bf32cfe7fda312309657759 100644
--- a/src/tabs/enquiries/pitch-builder/EditorAndTemplateBlocks.tsx
+++ b/src/tabs/enquiries/pitch-builder/EditorAndTemplateBlocks.tsx
@@ -288,50 +291,54 @@ const EditorAndTemplateBlocks: React.FC<EditorAndTemplateBlocksProps> = ({
     const editedText = editedContent[blockTitle]?.[optionLabel];
     if (editedText !== undefined) {
       return editedText;
     }
     return wrapInsertPlaceholders(originalContent);
   };
 
   // Wrap [INSERT] placeholders with contentEditable styling
   const wrapInsertPlaceholders = (text: string): string => {
     return text.replace(
       /\[INSERT[^\]]*\]/gi,
       (match) => `<span style="background-color: #fff3cd; color: #856404; padding: 2px 4px; border-radius: 3px; font-weight: 500;">${match}</span>`
     );
   };
 
   // Handle content editing
   const handleContentEdit = (blockTitle: string, optionLabel: string, content: string) => {
     setEditedContent(prev => ({
       ...prev,
       [blockTitle]: {
         ...prev[blockTitle],
         [optionLabel]: content
       }
     }));
 
+    if (markBlockAsEdited) {
+      markBlockAsEdited(blockTitle, true);
+    }
+
     // Debounced sync to main body for preview (300ms delay to avoid excessive updates)
     if (syncTimeoutRef.current) {
       clearTimeout(syncTimeoutRef.current);
     }
     
     syncTimeoutRef.current = setTimeout(() => {
       const block = templateBlocks.find(b => b.title === blockTitle);
       if (block && insertedBlocks[blockTitle]) {
         const modifiedBlock = {
           ...block,
           options: block.options.map(opt => 
             opt.label === optionLabel 
               ? { ...opt, previewText: content.replace(/<br\s*\/?>/gi, '\n') }
               : opt
           )
         };
         insertTemplateBlock(modifiedBlock, optionLabel, false);
       }
     }, 300);
   };
 
   // Handle auto-insert when user finishes editing (on blur)
   const handleContentBlur = (blockTitle: string, optionLabel: string) => {
     // Clear any pending sync timeout since we're syncing immediately on blur
     if (syncTimeoutRef.current) {
diff --git a/src/tabs/enquiries/pitch-builder/EditorAndTemplateBlocks.tsx b/src/tabs/enquiries/pitch-builder/EditorAndTemplateBlocks.tsx
index b23e67e0ed8948c62222ecdda445b2e484d6d442..6316ba5a632ecdda7bf32cfe7fda312309657759 100644
--- a/src/tabs/enquiries/pitch-builder/EditorAndTemplateBlocks.tsx
+++ b/src/tabs/enquiries/pitch-builder/EditorAndTemplateBlocks.tsx
@@ -524,51 +531,60 @@ const EditorAndTemplateBlocks: React.FC<EditorAndTemplateBlocksProps> = ({
               <div key={`${block.title}-${selectedOpt.label}-${blockIndex}`} style={{ 
                 borderBottom: blockIndex < templateBlocks.length - 1 ? '1px solid #f0f0f0' : 'none',
                 padding: '12px',
                 position: 'relative'
               }}>
                 {/* Block Title and Tabs */}
                 {!collapsedBlocks[`${block.title}-${selectedOpt.label}`] && (
                   <div style={{ 
                     display: 'flex',
                     alignItems: 'center',
                     marginBottom: '12px',
                     gap: '8px'
                   }}>
                     <Text styles={{
                       root: { 
                         fontSize: 11, 
                         fontWeight: 500, 
                         letterSpacing: '0.05px',
                         whiteSpace: 'nowrap'
                       } 
                     }}>
                       {block.title}:
                     </Text>
                     
                     {block.options.length > 1 && (
-                      <div style={{ display: 'flex', gap: '4px', alignItems: 'center', flex: 1 }}>
+                      <div
+                        style={{
+                          display: 'flex',
+                          gap: '4px',
+                          alignItems: 'center',
+                          flex: 1,
+                          opacity: editedBlocks[block.title] ? 0.5 : 1,
+                          pointerEvents: editedBlocks[block.title] ? 'none' : 'auto',
+                        }}
+                      >
                         {block.options.map((option) => {
                           const isSelected = option.label === selectedOption;
                           return (
                             <div
                               key={option.label}
                               style={{
                                 padding: '4px 8px',
                                 cursor: 'pointer',
                                 fontSize: '12px',
                                 fontWeight: isSelected ? 600 : 400,
                                 color: isSelected ? colours.highlight : 'rgba(30,30,30,0.45)',
                                 borderBottom: isSelected ? `2px solid ${colours.highlight}` : '2px solid transparent',
                                 position: 'relative'
                               }}
                               onClick={() => handleTabChange(block, option.label)}
                             >
                               {option.label}
                             </div>
                           );
                         })}
                       </div>
                     )}
 
                     {/* Remove block button - thin cross */}
                     <div
diff --git a/src/tabs/enquiries/pitch-builder/EditorAndTemplateBlocks.tsx b/src/tabs/enquiries/pitch-builder/EditorAndTemplateBlocks.tsx
index b23e67e0ed8948c62222ecdda445b2e484d6d442..6316ba5a632ecdda7bf32cfe7fda312309657759 100644
--- a/src/tabs/enquiries/pitch-builder/EditorAndTemplateBlocks.tsx
+++ b/src/tabs/enquiries/pitch-builder/EditorAndTemplateBlocks.tsx
@@ -652,51 +668,51 @@ const EditorAndTemplateBlocks: React.FC<EditorAndTemplateBlocksProps> = ({
                       transition: 'all 0.3s ease'
                     }}>
                       <div
                         ref={(el) => {
                           if (el) {
                             editorRefs.current[`${block.title}-${selectedOpt.label}`] = el;
                             // Set initial content immediately if empty
                             if (!el.innerHTML || el.innerHTML.trim() === '') {
                               const editedText = editedContent[block.title]?.[selectedOpt.label];
                               const contentToShow = editedText || wrapInsertPlaceholders(selectedOpt.previewText);
                               el.innerHTML = contentToShow;
                             }
                           }
                         }}
                         contentEditable={true}
                         suppressContentEditableWarning={true}
                         style={{
                           padding: '8px',
                           border: '1px solid #e8e8e8',
                           borderRadius: '4px',
                           fontSize: '13px',
                           lineHeight: '1.4',
                           whiteSpace: 'pre-wrap',
                           cursor: 'text',
                           outline: 'none',
-                          backgroundColor: '#ffffff',
+                          backgroundColor: editedBlocks[block.title] ? '#ffffff' : colours.highlightNeutral,
                           minHeight: '40px'
                         }}
                         onClick={(e) => handleEditorClick(block.title, selectedOpt.label, e)}
                         onInput={(e) => {
                           const content = (e.target as HTMLElement).innerHTML;
                           handleContentEdit(block.title, selectedOpt.label, content);
                         }}
                         onBlur={() => handleContentBlur(block.title, selectedOpt.label)}
                       />
                     </div>
 
                     {/* Original reference - slides in from right when shown */}
                     {showOriginal[`${block.title}-${selectedOpt.label}`] && (
                       <div style={{ 
                         flex: 1,
                         animation: 'slideInFromRight 0.3s ease-out'
                       }}>
                         <div
                           style={{
                             padding: '8px',
                             border: '1px solid #e8e8e8',
                             borderRadius: '4px',
                             fontSize: '13px',
                             lineHeight: '1.4',
                             whiteSpace: 'pre-wrap',
