diff --git a/src/tabs/instructions/DocumentsV3.tsx b/src/tabs/instructions/DocumentsV3.tsx
index 58dea4a082adb51fd39487f4cb6ea3721981278d..e127a5a687a87b9c01f6718159b0476052b82c20 100644
--- a/src/tabs/instructions/DocumentsV3.tsx
+++ b/src/tabs/instructions/DocumentsV3.tsx
@@ -1152,54 +1152,60 @@ const DocumentsV3: React.FC<DocumentsV3Props> = ({
                         onBlur={(e) => {
                             if (isTable) return;
                             let newText = e.target.textContent || '';
 
                             // Preserve bullet formatting - ensure lines that had bullets still have em dashes
                             const originalLines = content.substring(segmentStart, segmentEnd).split('\n');
                             const newLines = newText.split('\n');
 
                             // Restore em dashes for lines that should be bullets
                             const restoredLines = newLines.map((newLine, index) => {
                                 const originalLine = originalLines[index];
                                 if (originalLine && originalLine.match(/^—/)) {
                                     // This was originally a bullet line
                                     if (!newLine.match(/^—/)) {
                                         // If the em dash was lost, restore it
                                         return '—' + (newLine.startsWith('•') ? newLine.substring(1) : newLine);
                                     }
                                 }
                                 return newLine;
                             });
                             const spacingFixed = restoredLines.map(line =>
                                 line.replace(/^(\d+(?:\.\d+)*)(\S)/, '$1 $2')
                             );
 
                             newText = spacingFixed.join('\n');
-                            const beforeText = content.substring(0, segmentStart);
-                            const afterText = content.substring(segmentEnd);
-                            const newContent = beforeText + newText + afterText;
-                            setDocumentContent(newContent);
+                            const originalText = content.substring(segmentStart, segmentEnd);
+                            setDocumentContent(prev => {
+                                const start = prev.indexOf(originalText);
+                                if (start === -1) return prev;
+                                return (
+                                    prev.slice(0, start) +
+                                    newText +
+                                    prev.slice(start + originalText.length)
+                                );
+                            });
                         }}
                         style={{
                             outline: 'none',
                             minHeight: '1em',
                             display: isTable ? 'block' : 'inline',
                             whiteSpace: 'pre-wrap',
                             cursor: isTable ? 'default' : 'text',
                             padding: '2px',
                             borderRadius: '2px',
                             transition: 'background-color 0.2s ease'
                         }}
                     >
                         {nodes}
                     </div>
                 );
             }
             
             // Add the interactive inline editor for placeholders
             const rawBlockName = match[1].trim();
             const [blockLabelPart, blockKeyPart] = rawBlockName.split('::');
             const variableName = blockKeyPart ? blockKeyPart.trim() : rawBlockName;
 
             if (consumedPlaceholders.has(variableName)) {
                 lastIndex = match.index + match[0].length;
                 continue;
